filein( getFilenamePath(getSourceFileName()) + "/VertIslandFinder/VertIslandFinder.ms" )	--"./VertIslandFinder/VertIslandFinder.ms"

/**
 */
struct VertexLayers_v
(
	/* construct */
	obj,

	/* required */

	/* properties */
	--vertex_count,
	verts_all,
	--verts_process, -- canditate for supports
	--verts_pos,
	--verts_layers, -- #( #{3..8}, 2 ) vertex numbers in layer, if layer is empty, then layer index is stored

	--verts_support = #{},	-- final verts used for supports

	--bbox,
	layer_height = 0.05, -- height of print layer in mm

	/* dependency */
	VertIslandFinder,

	/* reference */
	/* inhered */
	/** Find points
	 */
	function findVertsOfNewIslands =
	(
		format "\n"; print "VertexLayers_v.findVertsOfNewIslands()"
		--this.vertex_count = getNumVerts obj.mesh
		VertIslandFinder.verts_all = verts_all = #{1..(getNumVerts obj.mesh)}

		format "VERTEX_COUNT: %\n" vertex_count

		/* GET VERTS WITH NORMAL POINTING DOWN */
		--bottom_verts = this.getBottom()

		/* GET ONLY CONVEX VERTS */
		--convex_verts = this.selectConvex()

		visible_verts = -( polyop.getHiddenVerts obj)


		verts_process = if (verts_sel = polyop.getVertSelection obj ).numberSet > 0 then verts_sel else verts_all

		VertIslandFinder.verts_process = verts_process * visible_verts



		this._sortVertsToLayers()
		format "verts_layers: %\n" verts_layers

		GET_ISLANDS = timeStamp()

		--VertIslandFinder.analyzeLayersByDetach(verts_all)(verts_process)(verts_layers)
		VertIslandFinder.getNewIslandsPerLayer()

		--format "\n GET_ISLANDS: % ms\n" (( timeStamp()) - GET_ISLANDS)
		--format "\n GET_ISLANDS: % seconds\n" ((( timeStamp()) - GET_ISLANDS) / 1000.0)

		--format "\n analyzeLayers: % seconds\n" ((( timeStamp()) - analyzeLayers) / 1000.0)
		--format "\n analyzeLayers: % ms\n" (( timeStamp()) - analyzeLayers)

		--obj	= selection[1]
		--
		--faces_selected = polyop.getFaceSelection obj
		--faces_all = #{1..(getNumFaces obj.mesh)}
		--
		--result = polyop.getElementsUsingFace obj faces_selected -- fence:<fence_facelist>
		--
		--format "result: %\n" result

		--format "verts_process: %\n" verts_process


		--this.selectVerts(bottom_verts * convex_verts * visible_verts)


		--this.selectVerts(bottom_verts)

		--this.selectVerts(verts_process)

		--this.selectVerts(convex_verts)

		--this.selectVerts( verts_layers[1]  )
		--
		--this.selectVerts( verts_layers[1] * verts_process )
		VertIslandFinder.new_islands --return

	),


	/** Set verts positions
	 */
	function _getVertsPositions =
	(
		format "\n"; print "VertDataGetter_v._getVertsPositions()"
		in coordsys world meshop.getVerts obj.mesh verts_all node:obj
	),

	/** Sort verts to layers
	 */
	function _sortVertsToLayers =
	(
		format "\n"; print "VertexLayers_v._sortVertsToLayers()"
		--fn compareZpos pos1 pos2 = if pos1.z < pos2.z then -1 else 1

		verts_process = VertIslandFinder.verts_process
		format "verts_process: %\n" verts_process

		--verts_in_layers = #{}

		verts_pos = this._getVertsPositions()

		--if verts_process.numberSet == verts_all.numberSet then
		--(
			bbox = nodeGetBoundingBox obj ( Matrix3 1)

			pos_z_min = bbox[1].z

			mesh_height = bbox[2].z - pos_z_min

			verts_fit = copy verts_all
		--)
		--else
		--(
		--	verts_above	= #{}
		--	verts_fit	= #{}
		--	verts_bellow	= #{}
		--
		--	verts_pos_z = for vert in verts_process collect verts_pos[vert].z
		--
		--	pos_z_min = amin verts_pos_z
		--	pos_z_max = amax verts_pos_z
		--
		--	mesh_height = pos_z_max - pos_z_min
		--	format "pos_z_min: %\n" pos_z_min
		--	format "pos_z_max: %\n" pos_z_max
		--	--for vert in verts_process where ( vert_pos_z = verts_pos[vert].z ) >= pos_z_min and vert_pos_z <= pos_z_max do verts_in_layers[vert] = true
		--
		--	sort_verts = timeStamp()
		--	for vert in verts_all do
		--	(
		--		vert_pos_z = verts_pos[vert].z
		--
		--		case of
		--		(
		--			(vert_pos_z > pos_z_max ):	verts_above[vert]	= true
		--			(vert_pos_z < pos_z_min ):	verts_bellow[vert]	= true
		--			default:	verts_fit[vert]	= true
		--		)
		--	)
		--	format "sort_verts: % ms\n" (( timeStamp()) - sort_verts)
		--
		--	VertIslandFinder.verts_above = verts_above
		--
		--	set_islands = timeStamp()
		--	VertIslandFinder.setVertsProcessed(verts_bellow)
		--	format "set_islands: % ms\n" (( timeStamp()) - set_islands)
		--
		--	format "VertIslandFinder.islands_all: %\n" VertIslandFinder.islands_all
		--	format "VertIslandFinder.islands_all.count: %\n" VertIslandFinder.islands_all.count
		--)

		layers_count = ceil ( mesh_height / layer_height)

		VertIslandFinder.verts_layers = #{1..(layers_count + 1)} as Array

		for vert in verts_fit do
		--for v = 1 to verts_pos.count do
		(
			layer = floor ( (verts_pos[vert].z - pos_z_min) / layer_height) + 1

			if superClassOf VertIslandFinder.verts_layers[layer] == Number then
				VertIslandFinder.verts_layers[layer] = #{vert} -- get first ert in layer

			else
				VertIslandFinder.verts_layers[layer][vert] = true
		)

		format "verts_above: %\n" verts_above
		format "verts_fit: %\n" verts_fit
		format "verts_bellow: %\n" verts_bellow

		--VertIslandFinder.verts_above = verts_above

			--verts_above	= #{}
			--verts_fit	= #{}
			--verts_bellow	= #{}

		--format "VERTS_LAYERS: %\n" verts_layers
		--format "VERTS_LAYERS: %\n" verts_layers.count
		--VertIslandFinder.verts_layers = verts_layers --return
	),

	/** Merge bit arrays in bit array
	 */
	function mergeBitArrays bit_array matches &bitarrays_merged =
	(
		--format "\n"; print ".mergeBitArraysInBitArray()"
		for m = matches.count to 1 by -1 do
		(
			bit_array += bitarrays_merged[matches[m]]

			deleteItem bitarrays_merged matches[m]
		)

		append bitarrays_merged bit_array

		bitarrays_merged --return
	),

	/**
	 */
	on create do
	(
		--format "\n"; print "VertexLayers.onCreate()"
		VertIslandFinder = VertIslandFinder_v(obj)
	)

)
